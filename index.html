<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Archivio Partigiani - Mappa AI</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,700&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
    
   <style>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   TAG CUSTOM PER IL LIBRO
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

libro-narrato {
    display: block;
    background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
    border-left: 5px solid #1976d2;
    padding: 20px 20px 20px 55px;
    margin: 20px 0;
    font-size: 15px;
    border-radius: 0 15px 15px 0;
    line-height: 1.7;
    position: relative;
    box-shadow: 0 4px 12px rgba(25, 118, 210, 0.2);
    font-family: 'Lora', serif;
    color: #0d47a1;
}

libro-narrato::before {
    content: 'ğŸ“–';
    position: absolute;
    left: 15px;
    top: 20px;
    font-size: 28px;
    opacity: 0.8;
}

libro-narrato::after {
    content: 'Dal Libro Storico';
    position: absolute;
    top: 8px;
    right: 15px;
    background: #1976d2;
    color: white;
    padding: 3px 10px;
    border-radius: 8px;
    font-size: 10px;
    font-weight: 700;
    letter-spacing: 0.5px;
    font-family: 'Inter', sans-serif;
}

libro-citazione {
    display: block;
    font-family: 'Lora', serif;
    font-style: italic;
    background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
    border-left: 5px double #f57c00;
    padding: 25px 25px 25px 60px;
    margin: 20px 0;
    color: #e65100;
    line-height: 1.8;
    border-radius: 0 15px 15px 0;
    position: relative;
    box-shadow: 0 4px 12px rgba(245, 124, 0, 0.2);
    font-size: 15px;
}

libro-citazione::before {
    content: '"';
    position: absolute;
    left: 20px;
    top: 15px;
    font-size: 50px;
    opacity: 0.3;
    font-family: Georgia, serif;
    color: #f57c00;
    line-height: 1;
}

libro-citazione::after {
    content: 'Citazione Libro';
    position: absolute;
    top: 8px;
    right: 15px;
    background: #f57c00;
    color: white;
    padding: 3px 10px;
    border-radius: 8px;
    font-size: 10px;
    font-weight: 700;
    letter-spacing: 0.5px;
    font-family: 'Inter', sans-serif;
    font-style: normal;
}

.libro-badge {
    display: inline-block;
    background: linear-gradient(135deg, #8b4513 0%, #a0522d 100%);
    color: white;
    padding: 4px 12px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: 700;
    margin-left: 8px;
    letter-spacing: 0.5px;
    box-shadow: 0 2px 5px rgba(139, 69, 19, 0.3);
}

#ai-progress-container {
    width: 100%;
    height: 4px;
    background: rgba(0,0,0,0.05);
    display: none;
    overflow: hidden;
}

#ai-progress-bar {
    width: 0%;
    height: 100%;
    background: var(--blue);
    transition: width 0.3s ease;
}

#ai-status-text {
    font-size: 11px;
    color: #666;
    padding: 5px 10px;
    text-align: center;
    display: none;
}

.progress-active {
    animation: pulse-progress 2s infinite ease-in-out;
}

@keyframes pulse-progress {
    0% { opacity: 0.6; }
    50% { opacity: 1; }
    100% { opacity: 0.6; }
}

:root { 
    --navy: #1a2a3a; 
    --blue: #3498db; 
    --glass: rgba(255, 255, 255, 0.4); 
    --red: #e21118; 
    --yellow: #ffcc00; 
}

.msg-ai { background: #f0f0f0; align-self: flex-start; line-height: 1.4; white-space: pre-wrap; position: relative; }
.msg-ai:after { content: 'â–‹'; animation: blink 1s infinite; margin-left: 5px; color: var(--blue); font-size: 12px; vertical-align: middle; }
.msg-ai.finished:after { content: ''; }
@keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }

body, html { margin: 0; padding: 0; height: 100%; width: 100%; font-family: 'Inter', sans-serif; overflow: hidden; background: #000; position: fixed; }

#map { 
    width: 100%; 
    height: 100%; 
    position: fixed !important; 
    top: 0; 
    left: 0; 
    bottom: 0;
    right: 0;
    z-index: 1; 
    background: #f0f0f0; 
}

#ui-container { position: absolute; top: 15px; left: 50%; transform: translateX(-50%); z-index: 5000; width: 95%; max-width: 1100px; }
#filter-bar { 
    background: rgba(255,255,255,0.85); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
    padding: 8px 15px; border-radius: 50px; box-shadow: 0 15px 35px rgba(0,0,0,0.3); 
    display: flex; gap: 8px; align-items: center; border: 1px solid rgba(255,255,255,0.4);
}
#filter-bar input, #filter-bar select { border: none; outline: none; flex: 1; font-size: 13px; background: transparent; font-weight: 700; color: #000; min-width: 60px; }

#results-dropdown { 
    background: rgba(255, 255, 255, 0.98); border-radius: 20px; margin-top: 5px; max-height: 300px; overflow-y: auto; 
    display: none; box-shadow: 0 10px 30px rgba(0,0,0,0.2); z-index: 9999; border: 1px solid rgba(0,0,0,0.1);
}
.res-item { padding: 10px 20px; cursor: pointer; border-bottom: 1px solid #eee; font-size: 13px; color: #000; font-weight: 600; display: flex; justify-content: space-between; }
.res-item:hover { background: var(--blue); color: white; }

#details-panel { 
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, 150%); 
    width: 94%; max-width: 1100px; z-index: 4000; 
    background: var(--glass); backdrop-filter: blur(35px) saturate(160%); -webkit-backdrop-filter: blur(35px) saturate(160%);
    transition: transform 0.6s cubic-bezier(0.19, 1, 0.22, 1); 
    border-radius: 30px; box-shadow: 0 40px 80px rgba(0,0,0,0.5); 
    display: flex; flex-direction: column; overflow: hidden; border: 1px solid rgba(255,255,255,0.5);
    max-height: 85vh;
}
#details-panel.open { transform: translate(-50%, -50%); }
#details-header { background: rgba(26, 42, 58, 0.85); color: white; padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; }
#details-content { display: flex; overflow: hidden; flex: 1; }
.main-col { flex: 1; overflow-y: auto; }
.video-box { width: 100%; aspect-ratio: 16/9; background: #000; }
.bio-box { padding: 15px 25px; line-height: 1.4; }
#text-bio { 
    font-family: 'Lora', serif; 
    font-size: 16px; 
    color: #1a1a1a; 
    text-align: justify;
    hyphens: auto;
}
#text-bio::first-letter {
    float: left;
    font-size: 3.5em;
    line-height: 0.7;
    padding-top: 4px;
    padding-right: 8px;
    color: var(--navy);
    font-weight: 700;
}

.side-rel { width: 250px; background: rgba(255, 255, 255, 0.1); padding: 15px; border-left: 1px solid rgba(0,0,0,0.1); overflow-y: auto; display: flex; flex-direction: column; }
.rel-item { padding: 6px 10px; background: rgba(255,255,255,0.4); border-radius: 8px; font-size: 11px; margin-bottom: 4px; cursor: pointer; font-weight: 600; }

.social-box { display: flex; justify-content: center; gap: 15px; margin-top: auto; padding-top: 15px; border-top: 1px solid rgba(0,0,0,0.1); }
.social-btn { display: flex; align-items: center; justify-content: center; width: 34px; height: 34px; border-radius: 50%; background: rgba(255,255,255,0.3); text-decoration: none; border: 1px solid rgba(255,255,255,0.4); }
.social-btn svg { width: 16px; height: 16px; fill: #1a2a3a; }

#ai-chat-toggle { position: absolute; bottom: 25px; right: 25px; z-index: 6000; width: 60px; height: 60px; background: #1a2a3a; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; box-shadow: 0 10px 25px rgba(0,0,0,0.4); border: 2px solid white; }

#ai-chat-window { 
    position: absolute; bottom: 95px; right: 25px; z-index: 6000; 
    width: 400px; height: 550px; 
    background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
    border-radius: 20px; display: none; flex-direction: column; overflow: hidden; 
    box-shadow: 0 20px 50px rgba(0,0,0,0.4); border: 1px solid rgba(255,255,255,0.3);
}

#ai-chat-messages { 
    flex: 1; padding: 15px; overflow-y: auto; 
    display: flex; flex-direction: column; gap: 12px;
}

.msg { 
    padding: 12px 16px; border-radius: 18px; max-width: 85%; 
    font-size: 14px; line-height: 1.5; box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}

.msg-user { 
    background: #1a2a3a; color: white; align-self: flex-end; 
    border-bottom-right-radius: 2px;
}

.msg-ai { 
    background: rgba(255, 255, 255, 0.9); 
    color: #2c3e50; 
    align-self: flex-start; 
    border-bottom-left-radius: 2px; 
    border: 1px solid rgba(0,0,0,0.05);
    backdrop-filter: blur(5px);
    line-height: 1.7;
    white-space: normal;
}

.msg-ai b[style*="color:var(--navy)"] {
    display: block;
    margin-top: 20px;
    margin-bottom: 10px;
    padding-bottom: 8px;
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    color: #1a2a3a !important;
    border-bottom: 2px solid #3498db;
    font-weight: 700;
}

.link-partigiano {
    color: #d35400;
    text-decoration: none;
    font-weight: 700;
    cursor: pointer;
    border-bottom: 1px solid transparent;
    transition: 0.2s;
}
.link-partigiano:hover {
    border-bottom: 1px solid #d35400;
    background: rgba(211, 84, 0, 0.05);
}

@media screen and (max-width: 768px) {
    #details-panel { 
        width: 100% !important; 
        height: 85vh !important; 
        position: fixed !important; 
        bottom: -100% !important; 
        top: auto !important; 
        left: 0 !important; 
        transform: none !important; 
        border-radius: 25px 25px 0 0 !important; 
        transition: bottom 0.5s ease !important; 
        z-index: 9999; 
    }
    #details-panel.open { bottom: 0 !important; }
    #details-content { flex-direction: column !important; overflow-y: auto !important; -webkit-overflow-scrolling: touch; }
    .video-box { position: sticky; top: 0; z-index: 10; min-height: 200px; }
    .main-col { overflow-y: visible !important; }
    .bio-box { padding: 15px 25px; line-height: 1.4; }
    #text-bio { 
        font-family: 'Lora', serif; 
        font-size: 16px; 
        color: #1a1a1a; 
        text-align: justify;
    }
    #text-bio::first-letter {
        float: left;
        font-size: 3.5em;
        line-height: 0.7;
        padding-top: 4px;
        padding-right: 8px;
        color: #1a2a3a;
        font-weight: 700;
    }
    .side-rel { width: 100% !important; border-left: none !important; border-top: 1px solid rgba(0,0,0,0.1); padding: 15px !important; padding-bottom: 80px !important; }
    #ai-chat-window { width: 94% !important; left: 3% !important; right: 3% !important; bottom: 80px !important; height: 60vh !important; }
}
</style>
</head>
<body>

<div id="ui-container">
    <div id="filter-bar">
        <button onclick="location.reload()" style="background:none; border:none; cursor:pointer; font-size:18px;">â†º</button>
        <input type="text" id="search-name" placeholder="Cognome..." oninput="filtra('name')">
        <input type="text" id="search-theme" placeholder="Temi..." oninput="filtra('theme')">
        <input type="text" id="search-city" placeholder="CittÃ ..." oninput="filtra('city')">
        <select id="filtro-regione" onchange="filtraRegione()">
            <option value="">Tutte le Regioni</option>
            <option value="Abruzzo">Abruzzo</option><option value="Basilicata">Basilicata</option>
            <option value="Calabria">Calabria</option><option value="Campania">Campania</option>
            <option value="Emilia-Romagna">Emilia-Romagna</option><option value="Friuli Venezia Giulia">Friuli Venezia Giulia</option>
            <option value="Lazio">Lazio</option><option value="Liguria">Liguria</option>
            <option value="Lombardia">Lombardia</option><option value="Marche">Marche</option>
            <option value="Molise">Molise</option><option value="Piemonte">Piemonte</option>
            <option value="Puglia">Puglia</option><option value="Sardegna">Sardegna</option>
            <option value="Sicilia">Sicilia</option><option value="Toscana">Toscana</option>
            <option value="Trentino-Alto Adige">Trentino-Alto Adige</option><option value="Umbria">Umbria</option>
            <option value="Valle d'Aosta">Valle d'Aosta</option><option value="Veneto">Veneto</option>
        </select>
    </div>
    <div id="results-dropdown"></div>
</div>

<div id="map"></div>

<div id="details-panel">
    <div id="details-header">
        <div><b id="h-nome">NOMINATIVO</b> <span id="h-reg" style="background:var(--blue); padding:2px 8px; border-radius:10px; font-size:10px; margin-left:10px;">REGIONE</span></div>
        <button onclick="closeDetails()" style="background:none; border:none; color:white; font-size:30px; cursor:pointer;">&times;</button>
    </div>
    <div id="details-content">
        <div class="main-col">
            <div class="video-box"><iframe id="vimeo-player" src="" width="100%" height="100%" frameborder="0" allowfullscreen></iframe></div>
            <div class="bio-box"><p id="text-bio"></p></div>
        </div>
        <div class="side-rel">
            <div id="box-rel-list"></div>
            <div id="box-social"></div>
        </div>
    </div>
</div>

<div id="ai-chat-toggle" onclick="toggleAIChat()">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
</div>

<div id="ai-chat-window">
    <div style="background:#1a2a3a; color:white; padding:12px; font-weight:700; display:flex; justify-content:space-between; align-items:center;">
        <span>Assistente Archivio XXX1.1</span>
        <span onclick="toggleAIChat()" style="cursor:pointer; padding: 5px 15px; font-size: 24px;">&times;</span>
    </div>
    <div id="ai-chat-messages"></div>
    
    <div id="ai-progress-container">
        <div id="ai-progress-bar"></div>
    </div>
    <div id="ai-status-text"></div>

    <div style="padding:10px; background:#fff; border-top:1px solid #eee; display:flex; align-items: flex-end; gap: 8px;">
        <textarea id="ai-chat-input" placeholder="Chiedi all'AI..." rows="1" 
            style="flex:1; border:1px solid #ccc; border-radius:10px; padding:8px 12px; font-size:14px; outline:none; resize:none; font-family:inherit;"
            oninput="this.style.height = ''; this.style.height = this.scrollHeight + 'px'"
            onkeypress="if(event.key==='Enter' && !event.shiftKey){ event.preventDefault(); sendAIMessage(); }"></textarea>
        
        <button onclick="sendAIMessage()" style="background:#1a2a3a; border:none; border-radius:50%; width:35px; height:35px; cursor:pointer; display:flex; align-items:center; justify-content:center; flex-shrink:0;">
            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
        </button>
    </div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
<script src="testo_libro.js"></script> 
<script>
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INIZIALIZZAZIONE MAPPA
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    let map = L.map('map', { 
        zoomControl: false,
        tap: false 
    }).setView([42.0, 12.5], 6);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: 'Â© OpenStreetMap'
    }).addTo(map);

    function fixMapSize() {
        setTimeout(() => {
            map.invalidateSize();
        }, 300);
    }
    window.addEventListener('load', fixMapSize);
    window.addEventListener('resize', fixMapSize);

    const stellaIcon = L.divIcon({
        className: 'stella',
        html: `<svg width="32" height="32" viewBox="0 0 100 100"><polygon points="50,5 61,39 98,39 68,60 79,94 50,74 21,94 32,60 2,39 39,39" fill="#e21118" stroke="#fff" stroke-width="3"/></svg>`,
        iconSize: [32, 32], iconAnchor: [16, 16]
    });

    let markers = L.markerClusterGroup({ disableClusteringAtZoom: 16 });
    map.addLayer(markers);
    let database = [];
    let searchTimeout;
    
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DIZIONARIO SINONIMI PER ESPANSIONE QUERY AI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const DIZIONARIO_SINONIMI = {
    "imi": "IMI internati militari italiani prigionia Germania lager Stammlager",
    "cln": "CLN Comitato di Liberazione Nazionale resistenza antifascismo",
    "gap": "GAP Gruppi di Azione Patriottica gappisti azioni urbane sabotaggio",
    "sap": "SAP Squadre di Azione Patriottica staffette ausiliarie",
    "rsi": "RSI Repubblica Sociale Italiana SalÃ² fascismo repubblichini",
    "lager": "lager campo di concentramento deportazione prigionia",
    "mauthausen": "Mauthausen campo concentramento Austria deportati sterminio",
    "partigiano": "partigiano partigiana resistente combattente patriota",
    "staffetta": "staffetta staffettista collegamento messaggera portaordini",
    "rastrellamento": "rastrellamento operazione polizia retata cattura arresto",
    "rappresaglia": "rappresaglia ritorsione strage eccidio massacro",
    "deportazione": "deportazione deportati trasferimento forzato tradotta",
    "8 settembre": "8 settembre 1943 armistizio Badoglio sbandamento esercito",
    "liberazione": "liberazione 25 aprile 1945 insurrezione fine guerra",
    "caduto": "caduto morto deceduto ucciso vittima perito",
    "brigata": "brigata divisione formazione partigiana banda gruppo armato"
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MOTORE DI INFERENZA STORICA AVANZATO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const INFERENZA_STORICA = {
    // Mappa lager â†’ localitÃ  geografiche
    LAGER_GEOGRAFIA: {
        "mauthausen": ["austria", "linz", "gusen"],
        "dachau": ["germania", "monaco", "baviera"],
        "auschwitz": ["polonia", "oswiecim"],
        "buchenwald": ["germania", "weimar", "turingia"],
        "flossenbÃ¼rg": ["germania", "baviera"],
        "sachsenhausen": ["germania", "berlino"],
        "ravensbrÃ¼ck": ["germania", "berlino"],
        "dora": ["germania", "nordhausen"]
    },
    
    // Eventi storici â†’ periodi temporali
    EVENTI_CRONOLOGIA: {
        "8 settembre": ["settembre 1943", "armistizio", "badoglio", "sbandamento"],
        "25 aprile": ["aprile 1945", "liberazione", "insurrezione"],
        "repubblica sociale": ["1943", "1944", "1945", "salÃ²"],
        "rastrellamenti": ["1944", "inverno 1944", "estate 1944"],
        "deportazioni": ["1943", "1944", "tradotte"]
    },
    
    // Ruoli â†’ implicazioni operative
    RUOLI_ATTIVITA: {
        "staffetta": ["collegamento", "messaggi", "portaordini", "ausiliaria", "donna", "giovane"],
        "gap": ["azioni urbane", "sabotaggio", "attentati", "cittÃ "],
        "sap": ["difesa", "ausiliaria", "supporto", "logistica"],
        "comandante": ["brigata", "divisione", "gruppo", "formazione"],
        "commissario": ["politico", "cln", "comitato"]
    },
    
    // Zone operative â†’ regioni correlate
    ZONE_OPERATIVE: {
        "valli valdesi": ["piemonte", "torino", "pinerolo"],
        "valsesia": ["piemonte", "vercelli", "novara"],
        "ossola": ["piemonte", "verbano", "svizzera"],
        "langhe": ["piemonte", "cuneo", "alba"],
        "appenino tosco-emiliano": ["emilia", "toscana", "modena", "bologna"],
        "carnia": ["friuli", "udine", "slovenia"],
        "val di fiemme": ["trentino", "trento"]
    },
    
    // Inferenze logiche: se query contiene X, aggiungi Y
    INFERENZE: [
        {
            pattern: /deport.*austria/i,
            aggiungi: ["mauthausen", "gusen", "linz", "deportati", "lager"],
            motivo: "Austria â†’ Mauthausen (principale lager)"
        },
        {
            pattern: /deport.*germania/i,
            aggiungi: ["dachau", "buchenwald", "flossenbÃ¼rg", "deportati", "lager"],
            motivo: "Germania â†’ lager tedeschi"
        },
        {
            pattern: /(donna|donne|femminil)/i,
            aggiungi: ["staffetta", "staffettista", "ausiliaria", "partigiana"],
            motivo: "Donne â†’ ruoli tipici nella resistenza"
        },
        {
            pattern: /cittÃ |urban/i,
            aggiungi: ["gap", "azioni urbane", "sabotaggio", "attentati"],
            motivo: "Contesto urbano â†’ GAP"
        },
        {
            pattern: /montagna|valli|alpini/i,
            aggiungi: ["brigata", "formazione", "bande", "rastrellamenti"],
            motivo: "Montagna â†’ formazioni partigiane"
        },
        {
            pattern: /settembre.*1943|armistizio/i,
            aggiungi: ["8 settembre", "sbandamento", "scelta", "badoglio"],
            motivo: "Armistizio â†’ momento cruciale"
        },
        {
            pattern: /imi|internati.*militari/i,
            aggiungi: ["germania", "lager", "stammlager", "prigionia", "8 settembre"],
            motivo: "IMI â†’ deportazione post-armistizio"
        },
        {
            pattern: /fucilat|uccis|cadut/i,
            aggiungi: ["rappresaglia", "rastrellamento", "catturato", "arrestato"],
            motivo: "Morte â†’ contesto di cattura"
        }
    ],
    
    // Espande la query con inferenze storiche
    espandiQuery(queryOriginale) {
        let terminiAggiuntivi = [];
        const queryLower = queryOriginale.toLowerCase();
        
        console.log("ğŸ§  [INFERENZA] Analisi query:", queryOriginale);
        
        // 1. Applica inferenze logiche
        this.INFERENZE.forEach(inferenza => {
            if (inferenza.pattern.test(queryOriginale)) {
                console.log(`  âœ… ${inferenza.motivo}`);
                terminiAggiuntivi.push(...inferenza.aggiungi);
            }
        });
        
        // 2. Espandi lager â†’ geografia
        for (const [lager, luoghi] of Object.entries(this.LAGER_GEOGRAFIA)) {
            if (queryLower.includes(lager)) {
                console.log(`  ğŸ“ ${lager} â†’ ${luoghi.join(', ')}`);
                terminiAggiuntivi.push(...luoghi);
            }
        }
        
        // 3. Espandi eventi â†’ cronologia
        for (const [evento, periodi] of Object.entries(this.EVENTI_CRONOLOGIA)) {
            if (queryLower.includes(evento)) {
                console.log(`  ğŸ“… ${evento} â†’ ${periodi.join(', ')}`);
                terminiAggiuntivi.push(...periodi);
            }
        }
        
        // 4. Espandi ruoli â†’ attivitÃ 
        for (const [ruolo, attivita] of Object.entries(this.RUOLI_ATTIVITA)) {
            if (queryLower.includes(ruolo)) {
                console.log(`  ğŸ‘¤ ${ruolo} â†’ ${attivita.join(', ')}`);
                terminiAggiuntivi.push(...attivita);
            }
        }
        
        // 5. Espandi zone â†’ regioni
        for (const [zona, regioni] of Object.entries(this.ZONE_OPERATIVE)) {
            if (queryLower.includes(zona)) {
                console.log(`  ğŸ—ºï¸ ${zona} â†’ ${regioni.join(', ')}`);
                terminiAggiuntivi.push(...regioni);
            }
        }
        
        // Rimuovi duplicati
        terminiAggiuntivi = [...new Set(terminiAggiuntivi)];
        
        if (terminiAggiuntivi.length > 0) {
            const queryEspansa = `${queryOriginale} ${terminiAggiuntivi.join(' ')}`;
            console.log(`ğŸ” [INFERENZA] Query espansa con ${terminiAggiuntivi.length} termini`);
            return queryEspansa;
        }
        
        return queryOriginale;
    }
};

function espandiQueryConSinonimi(queryOriginale) {
    // Prima espandi con sinonimi
    let queryEspansa = queryOriginale;
    let terminiAggiunti = [];
    const queryLower = queryOriginale.toLowerCase().trim();
    
    for (const [chiave, espansione] of Object.entries(DIZIONARIO_SINONIMI)) {
        const regex = new RegExp(`\\b${chiave.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
        
        if (regex.test(queryLower)) {
            const nuoviTermini = espansione.split(' ').filter(termine => 
                !queryLower.includes(termine.toLowerCase())
            );
            terminiAggiunti.push(...nuoviTermini);
        }
    }
    
    if (terminiAggiunti.length > 0) {
        const terminiUnici = [...new Set(terminiAggiunti)];
        queryEspansa = `${queryOriginale} ${terminiUnici.join(' ')}`;
        console.log('ğŸ“š [SINONIMI] Espansione:', terminiUnici.join(', '));
    }
    
    // Poi applica inferenze storiche
    queryEspansa = INFERENZA_STORICA.espandiQuery(queryEspansa);
    
    return queryEspansa;
}

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // SISTEMA DI CACHE PERSISTENTE AVANZATO
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const CACHE = {
        libroChunks: null,
        csvEmbeddings: null,
        libroEmbeddings: null,
        queryCache: new Map(),
        
        async initLibro() {
            if (this.libroEmbeddings || typeof TESTO_LIBRO === 'undefined') {
                console.log("ğŸ“š Libro non disponibile");
                return;
            }
            
            console.log("ğŸ”„ Inizializzazione libro...");
            
            this.libroChunks = TESTO_LIBRO
                .replace(/\n\s*\n/g, "###SPLIT###")
                .split("###SPLIT###")
                .map(p => p.trim())
                .filter(p => p.length > 100);
            
            console.log(`âœ… Libro pronto: ${this.libroChunks.length} chunks`);
            await this.precomputeLibroEmbeddings();
        },
        
        async precomputeLibroEmbeddings() {
            const key = localStorage.getItem('gemini_key');
            if (!key || !this.libroChunks) return;
            
            const cached = localStorage.getItem('libro_embeddings_v2');
            if (cached) {
                try {
                    this.libroEmbeddings = JSON.parse(cached);
                    console.log(`âœ… Embeddings libro da cache (${this.libroEmbeddings.length})`);
                    return;
                } catch (e) {
                    console.log("âš ï¸ Cache corrotta, ricalcolo...");
                }
            }
            
            console.log("ğŸ”„ Pre-calcolo embeddings libro...");
            this.libroEmbeddings = [];
            
            for (let i = 0; i < Math.min(this.libroChunks.length, 100); i += 5) {
                const batch = this.libroChunks.slice(i, i + 5);
                
                const embeddings = await Promise.all(batch.map(async (chunk) => {
                    try {
                        const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/text-embedding-004:embedContent?key=${key}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                model: "models/text-embedding-004",
                                content: { parts: [{ text: chunk.substring(0, 2000) }] }
                            })
                        });
                        const data = await res.json();
                        return data.embedding ? data.embedding.values : null;
                    } catch (e) {
                        return null;
                    }
                }));
                
                this.libroEmbeddings.push(...embeddings.filter(e => e !== null));
                await new Promise(resolve => setTimeout(resolve, 200));
            }
            
            try {
                localStorage.setItem('libro_embeddings_v2', JSON.stringify(this.libroEmbeddings));
                console.log(`âœ… Embeddings salvati (${this.libroEmbeddings.length})`);
            } catch (e) {
                console.log("âš ï¸ Storage pieno");
            }
        },
        
        async initCSV() {
            if (this.csvEmbeddings || database.length === 0) return;
            
            const key = localStorage.getItem('gemini_key');
            if (!key) return;
            
            const cached = localStorage.getItem('csv_embeddings_v2');
            if (cached) {
                try {
                    this.csvEmbeddings = JSON.parse(cached);
                    console.log(`âœ… Embeddings CSV da cache (${this.csvEmbeddings.length})`);
                    return;
                } catch (e) {
                    console.log("âš ï¸ Cache CSV corrotta");
                }
            }
            
            console.log("ğŸ”„ Pre-calcolo embeddings CSV...");
            this.csvEmbeddings = [];
            
            for (let i = 0; i < database.length; i += 10) {
                const batch = database.slice(i, i + 10);
                
                const embeddings = await Promise.all(batch.map(async (d) => {
                    try {
                        const docText = `${d.nominativo} ${d.scheda?.substring(0, 500) || ''} ${d.regione} ${d.cittÃ _nascita}`;
                        const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/text-embedding-004:embedContent?key=${key}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                model: "models/text-embedding-004",
                                content: { parts: [{ text: docText }] }
                            })
                        });
                        const data = await res.json();
                        return data.embedding ? data.embedding.values : null;
                    } catch (e) {
                        return null;
                    }
                }));
                
                this.csvEmbeddings.push(...embeddings.filter(e => e !== null));
                await new Promise(resolve => setTimeout(resolve, 200));
            }
            
            try {
                localStorage.setItem('csv_embeddings_v2', JSON.stringify(this.csvEmbeddings));
                console.log(`âœ… Embeddings CSV salvati (${this.csvEmbeddings.length})`);
            } catch (e) {
                console.log("âš ï¸ Storage pieno");
            }
        },
        
        getCachedQuery(query) {
            const normalized = query.toLowerCase().trim();
            return this.queryCache.get(normalized);
        },
        
        setCachedQuery(query, result, ttl = 3600000) {
            const normalized = query.toLowerCase().trim();
            this.queryCache.set(normalized, {
                result,
                timestamp: Date.now(),
                ttl
            });
            
            if (this.queryCache.size > 100) {
                const now = Date.now();
                for (const [key, value] of this.queryCache.entries()) {
                    if (now - value.timestamp > value.ttl) {
                        this.queryCache.delete(key);
                    }
                }
            }
        }
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CARICAMENTO DATABASE CSV
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    Papa.parse("progetto_mappa.csv", {
        download: true, header: true, skipEmptyLines: true,
        complete: function(res) {
            database = res.data.map(d => {
                let clean = {};
                Object.keys(d).forEach(k => clean[k.trim().toLowerCase()] = d[k]?.trim() || "");
                return clean;
            });
            caricaMarker();
            initBM25();
            
            const urlParams = new URLSearchParams(window.location.search);
            const nomep = urlParams.get('p');
            if (nomep) setTimeout(() => apri(decodeURIComponent(nomep)), 1000);
        }
    });

    window.addEventListener('load', () => {
        setTimeout(() => {
            CACHE.initLibro = async function() {
    if (this.libroEmbeddings || typeof TESTO_LIBRO === 'undefined') return;

    // Dividiamo il libro basandoci sui blocchi delle testimonianze.
    // Nel tuo testo, ogni storia inizia spesso con il nome e "Nato a..."
    // Usiamo una logica che raggruppa i paragrafi in blocchi piÃ¹ significativi (circa 2000 caratteri)
    const righe = TESTO_LIBRO.split('\n');
    let chunks = [];
    let chunkAttuale = "";

    for (let riga of righe) {
        chunkAttuale += riga + "\n";
        // Quando superiamo i 1500 caratteri e troviamo un punto, chiudiamo il chunk
        if (chunkAttuale.length > 1500 && riga.trim().endsWith('.')) {
            chunks.push(chunkAttuale.trim());
            chunkAttuale = "";
        }
    }
    if (chunkAttuale) chunks.push(chunkAttuale.trim());

    this.libroChunks = chunks.filter(c => c.length > 100);
    console.log(`âœ… Libro pronto: ${this.libroChunks.length} sezioni.`);
    await this.precomputeLibroEmbeddings();
};
    });

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // INTELLIGENZA GEOGRAFICA
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const GEO_INTELLIGENCE = {
        NORD: ['piemonte', 'valle d\'aosta', 'lombardia', 'trentino', 'alto adige', 'veneto', 'friuli', 'liguria', 'emilia', 'romagna'],
        CENTRO: ['toscana', 'umbria', 'marche', 'lazio', 'abruzzo', 'molise'],
        SUD: ['campania', 'puglia', 'basilicata', 'calabria', 'sicilia', 'sardegna'],
        
        classificaRegione(regione) {
            const r = regione.toLowerCase();
            if (this.NORD.some(n => r.includes(n))) return 'nord';
            if (this.CENTRO.some(c => r.includes(c))) return 'centro';
            if (this.SUD.some(s => r.includes(s))) return 'sud';
            return null;
        },
        
        parseRegioneSlash(regioneField) {
            if (regioneField.includes('/')) {
                const parts = regioneField.split('/').map(p => p.trim());
                return {
                    nascita: parts[0],
                    operazione: parts[1] || parts[0]
                };
            }
            return {
                nascita: regioneField,
                operazione: regioneField
            };
        },
        
        matchQueryGeografica(query) {
            const q = query.toLowerCase();
            
            const pattern1 = /nat[oi]\s+(?:al|in|nel|nella|nelle)\s+(nord|centro|sud).*(?:combat|operat|agit)[^\s]*\s+(?:al|in|nel|nella|nelle)\s+(nord|centro|sud)/i;
            const match1 = q.match(pattern1);
            if (match1) {
                return {
                    nascita: match1[1],
                    operazione: match1[2]
                };
            }
            
            if (q.includes('meridional') && (q.includes('nord') || q.includes('settentrion'))) {
                return {
                    nascita: 'sud',
                    operazione: 'nord'
                };
            }
            
            return null;
        },
        
        filtraPerGeografia(records, geoQuery) {
            return records.filter(d => {
                const parsed = this.parseRegioneSlash(d.regione);
                const nascitaClass = this.classificaRegione(parsed.nascita);
                const operazioneClass = this.classificaRegione(parsed.operazione);
                
                if (geoQuery.nascita && geoQuery.operazione) {
                    const nascitaMatch = nascitaClass === geoQuery.nascita.toLowerCase() || 
                                        parsed.nascita.toLowerCase().includes(geoQuery.nascita.toLowerCase());
                    const operazioneMatch = operazioneClass === geoQuery.operazione.toLowerCase() || 
                                           parsed.operazione.toLowerCase().includes(geoQuery.operazione.toLowerCase());
                    return nascitaMatch && operazioneMatch;
                }
                
                return false;
            });
        }
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MOTORE FILTRI
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const MotoreFiltri = {
        RAGGIO_MAX: 50000, 
        esegui: function(tipo) {
            const vn = document.getElementById('search-name').value.toLowerCase().trim();
            const vt = document.getElementById('search-theme').value.toLowerCase().trim();
            const vc = document.getElementById('search-city').value.toLowerCase().trim();
            const vr = document.getElementById('filtro-regione').value;

            let filtrati = database.filter(d => {
                const mNome = vn === "" || d.nominativo.toLowerCase().includes(vn);
                const mTema = vt === "" || (d.scheda && d.scheda.toLowerCase().includes(vt));
                const mReg  = vr === "" || (d.regione.trim().toLowerCase() === vr.toLowerCase());
                return mNome && mTema && mReg;
            });

            if (tipo === 'city' && vc.length >= 3) {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${vc},Italy&limit=1`)
                    .then(r => r.json()).then(data => {
                        if (data.length > 0) {
                            const centro = L.latLng(data[0].lat, data[0].lon);
                            flyDolce(centro, 10);
                            let vicini = filtrati.filter(d => {
                                const lat = parseFloat(d.lat?.replace(',','.'));
                                const lon = parseFloat(d.lon?.replace(',','.'));
                                return !isNaN(lat) && centro.distanceTo([lat, lon]) <= this.RAGGIO_MAX;
                            });
                            caricaMarker(d => vicini.includes(d), false);
                            this.renderDropdown(vicini.slice(0, 50), true); 
                        }
                    });
                }, 500);
            } else {
                this.aggiornaUI(filtrati, vr !== "");
            }
        },
        aggiornaUI: function(lista, nascondiRegione) {
            caricaMarker(d => lista.includes(d), false);
            const vn = document.getElementById('search-name').value;
            const vt = document.getElementById('search-theme').value;
            const vr = document.getElementById('filtro-regione').value;
            if (vn.length >= 2 || vt.length >= 2 || vr !== "") {
                this.renderDropdown(lista.slice(0, 50), nascondiRegione);
            } else {
                document.getElementById('results-dropdown').style.display = 'none';
            }
        },
        renderDropdown: function(lista, nascondiRegione) {
            const drop = document.getElementById('results-dropdown');
            if (lista.length > 0) {
                drop.innerHTML = lista.map(d => {
                    const safeName = d.nominativo.replace(/'/g, "\\'");
                    const info = d.cittÃ _nascita || d.regione; 
                    return `<div class="res-item" onclick="apri('${safeName}')">
                                <b>${d.nominativo}</b> 
                                <span style="font-size:11px;opacity:0.6">${info}</span>
                            </div>`;
                }).join('');
                drop.style.display = 'block';
            } else {
                drop.innerHTML = '<div class="res-item">Nessun risultato</div>';
                drop.style.display = 'block';
            }
        }
    };

    function filtra(tipo) { MotoreFiltri.esegui(tipo); }
    function filtraRegione() { MotoreFiltri.esegui('regione'); }

    function flyDolce(target, zoom = 12) { 
        map.flyTo(target, zoom, { duration: 3.5, easeLinearity: 0.1, noMoveStart: true }); 
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // GESTIONE MARKER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function caricaMarker(filtroFn = null, fit = false) {
        markers.clearLayers();
        let bounds = L.latLngBounds();
        let hasData = false;
        database.forEach(d => {
            if (!filtroFn || filtroFn(d)) {
                const lat = parseFloat(d.lat?.replace(',','.')), lon = parseFloat(d.lon?.replace(',','.'));
                if (!isNaN(lat) && !isNaN(lon)) {
                    let m = L.marker([lat, lon], { icon: stellaIcon });
                    m.bindTooltip(`<b>${d.nominativo}</b>`, { direction: 'top', offset: [0, -10] });
                    m.on('click', (e) => { L.DomEvent.stopPropagation(e); openDetails(d); });
                    m.on('mouseover', function() {
                        this.getElement().style.filter = "brightness(1.5) saturate(2)";
                    });
                    m.on('mouseout', function() {
                        this.getElement().style.filter = "none";
                    });
                    markers.addLayer(m);
                    bounds.extend([lat, lon]);
                    hasData = true;
                }
            }
        });
        if (hasData && fit) map.flyToBounds(bounds, {padding: [50, 50], duration: 2.5});
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PANNELLO DETTAGLI
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function openDetails(d) {
        let bio = d.scheda || "Nessuna biografia disponibile.";
        if (bio.startsWith(d.nominativo)) {
            bio = bio.replace(d.nominativo, "").trim();
            bio = bio.charAt(0).toUpperCase() + bio.slice(1);
        }

        let bioFormattata = bio.replace(/\. ?([A-Z])/g, '.<br><span style="display:block; margin-top:8px;"></span>$1');

        document.getElementById('h-nome').innerText = d.nominativo.toUpperCase();
        document.getElementById('h-reg').innerText = d.regione;
        document.getElementById('text-bio').innerHTML = bioFormattata;
        
        document.getElementById('vimeo-player').src = d.id ? `https://player.vimeo.com/video/${d.id}?autoplay=0` : "";
        
        const rel = database.filter(x => x.regione === d.regione && x.nominativo !== d.nominativo).slice(0, 15);
        document.getElementById('box-rel-list').innerHTML = `<div style="font-size:9px; font-weight:800; opacity:0.5; margin-bottom:10px; letter-spacing:1px;">CORRELATI / ${d.regione.toUpperCase()}</div>` + 
            rel.map(r => `<div class="rel-item" onclick="apri('${r.nominativo.replace(/'/g, "\\'")}')">${r.nominativo}</div>`).join('');
        
        const shareUrl = window.location.origin + window.location.pathname + "?p=" + encodeURIComponent(d.nominativo);
        document.getElementById('box-social').innerHTML = `
            <div class="social-box">
                <a class="social-btn" href="https://api.whatsapp.com/send?text=${encodeURIComponent(d.nominativo + " " + shareUrl)}" target="_blank"><svg viewBox="0 0 24 24"><path d="M17.472 14.382c-.297-.149-1.758-.867-2.03-.967-.273-.099-.471-.148-.67.15-.197.297-.767.966-.94 1.164-.173.199-.347.223-.644.075-.297-.15-1.255-.463-2.39-1.475-.883-.788-1.48-1.761-1.653-2.059-.173-.297-.018-.458.13-.606.134-.133.298-.347.446-.52.149-.174.198-.298.298-.497.099-.198.05-.371-.025-.52-.075-.149-.669-1.612-.916-2.207-.242-.579-.487-.5-.669-.51-.173-.008-.371-.01-.57-.01-.198 0-.52.074-.792.372-.272.297-1.04 1.016-1.04 2.479 0 1.462 1.065 2.875 1.213 3.074.149.198 2.096 3.2 5.077 4.487.709.306 1.262.489 1.694.625.712.227 1.36.195 1.871.118.571-.085 1.758-.719 2.006-1.413.248-.694.248-1.289.173-1.413-.074-.124-.272-.198-.57-.347m-5.421 7.403h-.004a9.27 9.27 0 01-4.487-1.164l-.325-.193-3.34.877.89-3.253-.213-.339a9.27 9.27 0 01-1.421-4.906c0-5.113 4.158-9.27 9.274-9.27 2.476 0 4.803.965 6.556 2.719a9.23 9.23 0 012.716 6.558c0 5.116-4.158 9.274-9.274 9.274m10.963-12.713A11.01 11.01 0 0012.048 2.73c-6.103 0-11.07 4.966-11.07 11.07 0 1.95.51 3.855 1.478 5.533L.65 23.35l4.103-1.076a11.002 11.002 0 005.293 1.358h.005c6.101 0 11.07-4.968 11.07-11.072 0-2.956-1.15-5.736-3.238-7.824z"/></svg></a>
                <a class="social-btn" href="https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(shareUrl)}" target="_blank"><svg viewBox="0 0 24 24"><path d="M22 12c0-5.52-4.48-10-10-10S2 6.48 2 12c0 4.99 3.66 9.12 8.44 9.88v-6.99H7.9v-2.89h2.54V9.8c0-2.51 1.49-3.89 3.78-3.89 1.09 0 2.23.19 2.23.19v2.45h-1.26c-1.24 0-1.63.77-1.63 1.56v1.88h2.77l-.44 2.89h-2.33v6.99C18.34 21.12 22 16.99 22 12z"/></svg></a>
                <a class="social-btn" href="javascript:void(0)" onclick="navigator.clipboard.writeText('${shareUrl}'); alert('Link copiato!')"><svg viewBox="0 0 24 24"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"/></svg></a>
            </div>`;
        document.getElementById('details-panel').classList.add('open');
    }

    function closeDetails() { 
        document.getElementById('details-panel').classList.remove('open'); 
        setTimeout(() => { document.getElementById('vimeo-player').src = ""; }, 500); 
    }

    function apri(nome) {
        const d = database.find(x => x.nominativo.toLowerCase().includes(nome.toLowerCase().trim()));
        if(!d) return;
        document.getElementById('results-dropdown').style.display = 'none';
        openDetails(d);
        const lat = parseFloat(d.lat?.replace(',','.')), lon = parseFloat(d.lon?.replace(',','.'));
        if(!isNaN(lat)) flyDolce([lat, lon], 15);
    }

    function toggleAIChat() {
        const win = document.getElementById('ai-chat-window');
        win.style.display = (win.style.display === 'none' || win.style.display === '') ? 'flex' : 'none';
        if(win.style.display === 'flex') document.getElementById('ai-chat-input').focus();
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // FUNZIONI UTILITY
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function updateProgress(percent, message) {
        const pBar = document.getElementById('ai-progress-bar');
        const statusDiv = document.getElementById('ai-status-text');
        pBar.style.width = percent + '%';
        statusDiv.textContent = message;
        statusDiv.style.display = 'block';
    }

    function cosineSimilarity(vecA, vecB) {
        const dotProduct = vecA.reduce((sum, val, i) => sum + val * vecB[i], 0);
        const normA = Math.sqrt(vecA.reduce((sum, val) => sum + val * val, 0));
        const normB = Math.sqrt(vecB.reduce((sum, val) => sum + val * val, 0));
        return dotProduct / (normA * normB);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // BM25
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    class BM25 {
        constructor(documents, k1 = 1.5, b = 0.75) {
            this.k1 = k1;
            this.b = b;
            this.documents = documents;
            this.docCount = documents.length;
            this.avgDocLength = 0;
            this.docLengths = [];
            this.idf = {};
            this.initialize();
        }
        
        tokenize(text) {
            return text.toLowerCase()
                .replace(/[^\w\s]/g, ' ')
                .split(/\s+/)
                .filter(t => t.length > 2);
        }
        
        initialize() {
            const docFreq = {};
            let totalLength = 0;
            
            this.documents.forEach((doc, i) => {
                const tokens = this.tokenize(doc);
                this.docLengths[i] = tokens.length;
                totalLength += tokens.length;
                
                const uniqueTokens = new Set(tokens);
                uniqueTokens.forEach(token => {
                    docFreq[token] = (docFreq[token] || 0) + 1;
                });
            });
            
            this.avgDocLength = totalLength / this.docCount;
            
            for (const token in docFreq) {
                this.idf[token] = Math.log((this.docCount - docFreq[token] + 0.5) / (docFreq[token] + 0.5) + 1);
            }
        }
        
        score(queryTokens, docIndex) {
            const docTokens = this.tokenize(this.documents[docIndex]);
            const docLength = this.docLengths[docIndex];
            const tokenFreq = {};
            
            docTokens.forEach(token => {
                tokenFreq[token] = (tokenFreq[token] || 0) + 1;
            });
            
            let score = 0;
            queryTokens.forEach(token => {
                if (this.idf[token] && tokenFreq[token]) {
                    const tf = tokenFreq[token];
                    const idf = this.idf[token];
                    const norm = this.k1 * (1 - this.b + this.b * (docLength / this.avgDocLength));
                    score += idf * (tf * (this.k1 + 1)) / (tf + norm);
                }
            });
            
            return score;
        }
        
        search(query, topK = 50) {
            const queryTokens = this.tokenize(query);
            const scores = this.documents.map((_, i) => ({
                index: i,
                score: this.score(queryTokens, i)
            }));
            
            return scores
                .filter(s => s.score > 0)
                .sort((a, b) => b.score - a.score)
                .slice(0, topK)
                .map(s => s.index);
        }
    }

    let bm25Index = null;

    function initBM25() {
        if (bm25Index || database.length === 0) return;
        
        console.log("ğŸ”„ Inizializzazione BM25...");
        const documents = database.map(d => 
            `${d.nominativo} ${d.scheda || ''} ${d.regione} ${d.cittÃ _nascita}`.toLowerCase()
        );
        bm25Index = new BM25(documents);
        console.log(`âœ… BM25 pronto (${database.length} documenti)`);
    }

    async function hybridSearch(query, topK = 30) {
        initBM25();
        
        const bm25Results = bm25Index.search(query, 100);
        
        let semanticResults = [];
        if (CACHE.csvEmbeddings && CACHE.csvEmbeddings.length > 0) {
            const key = localStorage.getItem('gemini_key');
            if (key) {
                try {
                    const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/text-embedding-004:embedContent?key=${key}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            model: "models/text-embedding-004",
                            content: { parts: [{ text: query }] }
                        })
                    });
                    const data = await res.json();
                    
                    if (data.embedding) {
                        const queryEmbed = data.embedding.values;
                        
                        semanticResults = CACHE.csvEmbeddings
                            .map((embed, i) => ({
                                index: i,
                                score: cosineSimilarity(queryEmbed, embed)
                            }))
                            .filter(s => s.score > 0.25)
                            .sort((a, b) => b.score - a.score)
                            .slice(0, 100)
                            .map(s => s.index);
                    }
                } catch (e) {
                    console.error("Errore semantica:", e);
                }
            }
        }
        
        const k = 60;
        const scores = {};
        
        bm25Results.forEach((idx, rank) => {
            scores[idx] = (scores[idx] || 0) + 1 / (k + rank + 1);
        });
        
        semanticResults.forEach((idx, rank) => {
            scores[idx] = (scores[idx] || 0) + 1 / (k + rank + 1);
        });
        
        const fusedResults = Object.entries(scores)
            .map(([idx, score]) => ({ index: parseInt(idx), score }))
            .sort((a, b) => b.score - a.score)
            .slice(0, topK)
            .map(s => database[s.index]);
        
        console.log(`âœ… Trovati ${fusedResults.length} risultati`);
        return fusedResults;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ANALIZZATORE DI PERCORSI E COLLEGAMENTI AVANZATO
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    function analizzaPercorsiComplessi(partigiani) {
        const percorsi = {
            migrazioniGeografiche: [],
            retiBrigate: [],
            cronologieCondivise: [],
            zoneOperative: [],
            destiniComuni: []
        };
        
        // 1. MIGRAZIONI GEOGRAFICHE (nascita â†’ operazione)
        const migrazioni = {};
        partigiani.forEach(p => {
            if (p.regione.includes('/')) {
                const [nascita, operazione] = p.regione.split('/').map(r => r.trim());
                if (nascita !== operazione) {
                    const chiave = `${nascita}â†’${operazione}`;
                    if (!migrazioni[chiave]) migrazioni[chiave] = [];
                    migrazioni[chiave].push({
                        nome: p.nominativo,
                        citta: p.cittÃ _nascita,
                        bio: p.scheda
                    });
                }
            }
        });
        
        for (const [percorso, membri] of Object.entries(migrazioni)) {
            if (membri.length >= 2) {
                // Analizza le formazioni comuni tra i migranti
                const formazioniComuni = {};
                membri.forEach(m => {
                    const bioLower = (m.bio || '').toLowerCase();
                    const matchBrigata = bioLower.match(/brigata\s+([a-z]+)/i);
                    if (matchBrigata) {
                        const brigata = matchBrigata[0];
                        if (!formazioniComuni[brigata]) formazioniComuni[brigata] = [];
                        formazioniComuni[brigata].push(m.nome);
                    }
                });
                
                percorsi.migrazioniGeografiche.push({
                    percorso,
                    conteggio: membri.length,
                    membri: membri.map(m => m.nome),
                    citta: [...new Set(membri.map(m => m.citta).filter(c => c))],
                    formazioni: formazioniComuni
                });
            }
        }
        
        // 2. RETI DI BRIGATE E FORMAZIONI
        const brigate = {};
        partigiani.forEach(p => {
            const bio = p.scheda || '';
            const matches = bio.match(/(?:brigata|divisione|battaglione)\s+([a-zA-ZÃ Ã¨Ã©Ã¬Ã²Ã¹\s]+?)(?:\.|,|;|\s+nel|\s+della)/gi);
            if (matches) {
                matches.forEach(match => {
                    const brigata = match.trim();
                    if (!brigate[brigata]) brigate[brigata] = [];
                    brigate[brigata].push({
                        nome: p.nominativo,
                        regione: p.regione,
                        bio: p.scheda
                    });
                });
            }
        });
        
        for (const [brigata, membri] of Object.entries(brigate)) {
            if (membri.length >= 2) {
                // Analizza eventi comuni nella brigata
                const eventiComuni = [];
                const bioUnita = membri.map(m => m.bio).join(' ').toLowerCase();
                if (bioUnita.includes('rastrellamento')) eventiComuni.push('rastrellamento');
                if (bioUnita.includes('8 settembre')) eventiComuni.push('8 settembre');
                if (bioUnita.includes('cattura')) eventiComuni.push('cattura');
                if (bioUnita.includes('fucilat')) eventiComuni.push('fucilazione');
                
                percorsi.retiBrigate.push({
                    brigata,
                    conteggio: membri.length,
                    membri: membri.map(m => m.nome),
                    regioni: [...new Set(membri.map(m => m.regione.split('/')[0]))],
                    eventi: eventiComuni
                });
            }
        }
        
        // 3. CRONOLOGIE CONDIVISE (eventi nello stesso periodo)
        const eventi = {
            '8 settembre': [],
            'rastrellamento': [],
            'deportazione': [],
            'liberazione': [],
            '1944': [],
            '1945': []
        };
        
        partigiani.forEach(p => {
            const bio = (p.scheda || '').toLowerCase();
            for (const [evento, lista] of Object.entries(eventi)) {
                if (bio.includes(evento)) {
                    lista.push({
                        nome: p.nominativo,
                        regione: p.regione,
                        bio: p.scheda
                    });
                }
            }
        });
        
        for (const [evento, membri] of Object.entries(eventi)) {
            if (membri.length >= 3) {
                // Trova sotto-gruppi con dettagli specifici
                const dettagli = {};
                membri.forEach(m => {
                    const bio = m.bio.toLowerCase();
                    if (evento === 'rastrellamento') {
                        const match = bio.match(/rastrellamento\s+(?:del|di|in)\s+([a-z\s]+?)(?:\.|,|nel)/i);
                        if (match) {
                            const luogo = match[1].trim();
                            if (!dettagli[luogo]) dettagli[luogo] = [];
                            dettagli[luogo].push(m.nome);
                        }
                    }
                });
                
                percorsi.cronologieCondivise.push({
                    evento,
                    conteggio: membri.length,
                    membri: membri.map(m => m.nome),
                    dettagli
                });
            }
        }
        
        // 4. ZONE OPERATIVE COMUNI
        const zone = {};
        const zoneKeywords = ['valsesia', 'val d\'ossola', 'langhe', 'carnia', 'appennino', 'prealpi', 'val di susa', 'val chisone'];
        
        partigiani.forEach(p => {
            const bio = (p.scheda || '').toLowerCase();
            zoneKeywords.forEach(zona => {
                if (bio.includes(zona)) {
                    if (!zone[zona]) zone[zona] = [];
                    zone[zona].push({
                        nome: p.nominativo,
                        regione: p.regione
                    });
                }
            });
        });
        
        for (const [zona, membri] of Object.entries(zone)) {
            if (membri.length >= 2) {
                percorsi.zoneOperative.push({
                    zona,
                    conteggio: membri.length,
                    membri: membri.map(m => m.nome)
                });
            }
        }
        
        // 5. DESTINI COMUNI (deportazione, fucilazione, ecc.)
        const destini = {
            'mauthausen': [],
            'dachau': [],
            'buchenwald': [],
            'fucilat': [],
            'cadut': []
        };
        
        partigiani.forEach(p => {
            const bio = (p.scheda || '').toLowerCase();
            for (const [destino, lista] of Object.entries(destini)) {
                if (bio.includes(destino)) {
                    lista.push({
                        nome: p.nominativo,
                        regione: p.regione,
                        bio: p.scheda
                    });
                }
            }
        });
        
        for (const [destino, membri] of Object.entries(destini)) {
            if (membri.length >= 2) {
                percorsi.destiniComuni.push({
                    destino,
                    conteggio: membri.length,
                    membri: membri.map(m => m.nome)
                });
            }
        }
        
        return percorsi;
    }
    
    function generaTestoPercorsi(percorsi) {
        let testo = "";
        
        if (percorsi.migrazioniGeografiche.length > 0) {
            testo += "PERCORSI GEOGRAFICI:\n";
            percorsi.migrazioniGeografiche.forEach(p => {
                testo += `- ${p.percorso}: ${p.membri.slice(0, 8).join(', ')}${p.membri.length > 8 ? '...' : ''} (${p.conteggio} persone)\n`;
                if (Object.keys(p.formazioni).length > 0) {
                    for (const [formazione, nomi] of Object.entries(p.formazioni)) {
                        testo += `  â†’ Nella ${formazione}: ${nomi.join(', ')}\n`;
                    }
                }
            });
            testo += "\n";
        }
        
        if (percorsi.retiBrigate.length > 0) {
            testo += "FORMAZIONI COMUNI:\n";
            percorsi.retiBrigate.forEach(p => {
                testo += `- ${p.brigata}: ${p.membri.slice(0, 6).join(', ')}${p.membri.length > 6 ? '...' : ''} (${p.conteggio} membri)\n`;
                if (p.eventi.length > 0) {
                    testo += `  â†’ Eventi: ${p.eventi.join(', ')}\n`;
                }
            });
            testo += "\n";
        }
        
        if (percorsi.zoneOperative.length > 0) {
            testo += "ZONE OPERATIVE:\n";
            percorsi.zoneOperative.forEach(p => {
                testo += `- ${p.zona}: ${p.membri.slice(0, 6).join(', ')}${p.membri.length > 6 ? '...' : ''} (${p.conteggio} operativi)\n`;
            });
            testo += "\n";
        }
        
        if (percorsi.cronologieCondivise.length > 0) {
            testo += "EVENTI CONDIVISI:\n";
            percorsi.cronologieCondivise.forEach(p => {
                testo += `- ${p.evento}: ${p.conteggio} partigiani\n`;
                if (Object.keys(p.dettagli).length > 0) {
                    for (const [luogo, nomi] of Object.entries(p.dettagli)) {
                        if (nomi.length >= 2) {
                            testo += `  â†’ ${luogo}: ${nomi.slice(0, 4).join(', ')}${nomi.length > 4 ? '...' : ''}\n`;
                        }
                    }
                }
            });
            testo += "\n";
        }
        
        if (percorsi.destiniComuni.length > 0) {
            testo += "DESTINI COMUNI:\n";
            percorsi.destiniComuni.forEach(p => {
                testo += `- ${p.destino}: ${p.membri.slice(0, 8).join(', ')}${p.membri.length > 8 ? '...' : ''} (${p.conteggio} persone)\n`;
            });
        }
        
        return testo;
    }
    
    function analizzaRelazioni(partigiani) {
        const relazioni = {
            geografiche: [],
            temporali: [],
            organizzative: [],
            tematiche: []
        };
        
        const gruppiRegione = {};
        const gruppiCitta = {};
        
        partigiani.forEach(p => {
            const regione = p.regione.split('/')[0].trim();
            if (!gruppiRegione[regione]) gruppiRegione[regione] = [];
            gruppiRegione[regione].push(p.nominativo);
            
            if (p.cittÃ _nascita) {
                if (!gruppiCitta[p.cittÃ _nascita]) gruppiCitta[p.cittÃ _nascita] = [];
                gruppiCitta[p.cittÃ _nascita].push(p.nominativo);
            }
        });
        
        for (const [regione, nomi] of Object.entries(gruppiRegione)) {
            if (nomi.length >= 3) {
                relazioni.geografiche.push({
                    tipo: 'regione',
                    valore: regione,
                    membri: nomi,
                    conteggio: nomi.length
                });
            }
        }
        
        for (const [citta, nomi] of Object.entries(gruppiCitta)) {
            if (nomi.length >= 2) {
                relazioni.geografiche.push({
                    tipo: 'cittÃ ',
                    valore: citta,
                    membri: nomi,
                    conteggio: nomi.length
                });
            }
        }
        
        const temiComuni = {};
        const keywords = [
            'deportato', 'deportazione', 'lager', 'mauthausen', 'dachau',
            'IMI', 'internato', 'militare',
            'GAP', 'SAP', 'brigata', 'divisione', 'battaglione',
            'staffetta', 'staffettista',
            'CLN', 'comitato',
            'fucilato', 'caduto', 'catturato', 'arrestato',
            'rastrellamento', 'rappresaglia', 'strage',
            '8 settembre', 'liberazione', '25 aprile',
            'partigiano', 'partigiana', 'combattente'
        ];
        
        partigiani.forEach(p => {
            const bio = (p.scheda || '').toLowerCase();
            keywords.forEach(kw => {
                if (bio.includes(kw.toLowerCase())) {
                    if (!temiComuni[kw]) temiComuni[kw] = [];
                    temiComuni[kw].push(p.nominativo);
                }
            });
        });
        
        for (const [tema, nomi] of Object.entries(temiComuni)) {
            if (nomi.length >= 2) {
                relazioni.tematiche.push({
                    tema,
                    membri: nomi,
                    conteggio: nomi.length
                });
            }
        }
        
        const formazioniRegex = /(?:brigata|divisione|battaglione|gruppo|banda)\s+([a-zA-ZÃ Ã¨Ã©Ã¬Ã²Ã¹Ã€ÃˆÃ‰ÃŒÃ’Ã™\s]+)/gi;
        const formazioni = {};
        
        partigiani.forEach(p => {
            const bio = p.scheda || '';
            let match;
            while ((match = formazioniRegex.exec(bio)) !== null) {
                const nomeFormazione = match[0].trim();
                if (!formazioni[nomeFormazione]) formazioni[nomeFormazione] = [];
                formazioni[nomeFormazione].push(p.nominativo);
            }
        });
        
        for (const [formazione, nomi] of Object.entries(formazioni)) {
            if (nomi.length >= 2) {
                relazioni.organizzative.push({
                    formazione,
                    membri: nomi,
                    conteggio: nomi.length
                });
            }
        }
        
        const migrazioni = {};
        partigiani.forEach(p => {
            if (p.regione.includes('/')) {
                const [nascita, operazione] = p.regione.split('/').map(r => r.trim());
                if (nascita !== operazione) {
                    const chiave = `${nascita} â†’ ${operazione}`;
                    if (!migrazioni[chiave]) migrazioni[chiave] = [];
                    migrazioni[chiave].push(p.nominativo);
                }
            }
        });
        
        relazioni.migrazioni = Object.entries(migrazioni)
            .filter(([_, nomi]) => nomi.length >= 2)
            .map(([percorso, nomi]) => ({
                percorso,
                membri: nomi,
                conteggio: nomi.length
            }));
        
        return relazioni;
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // RICERCA LIBRO OTTIMIZZATA
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    async function searchLibroSemantico(query, topK = 3) {
        if (!CACHE.libroChunks || CACHE.libroChunks.length === 0) {
            console.log("ğŸ“š Libro non disponibile");
            return { chunks: [], maxScore: 0 };
        }
        
        const key = localStorage.getItem('gemini_key');
        if (!key) return { chunks: [], maxScore: 0 };
        
        try {
            if (!CACHE.libroEmbeddings || CACHE.libroEmbeddings.length === 0) {
                console.log("ğŸ“š Embeddings libro non disponibili");
                return { chunks: [], maxScore: 0 };
            }
            
            const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/text-embedding-004:embedContent?key=${key}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    model: "models/text-embedding-004",
                    content: { parts: [{ text: query }] }
                })
            });
            const data = await res.json();
            
            if (!data.embedding) return { chunks: [], maxScore: 0 };
            
            const queryEmbed = data.embedding.values;
            
            const scoredChunks = CACHE.libroEmbeddings
                .map((embed, i) => ({
                    chunk: CACHE.libroChunks[i],
                    score: cosineSimilarity(queryEmbed, embed)
                }))
                .filter(s => s.score >= 0.35)
                .sort((a, b) => b.score - a.score)
                .slice(0, topK);
            
            const maxScore = scoredChunks.length > 0 ? scoredChunks[0].score : 0;
            
            if (scoredChunks.length === 0) {
                console.log("ğŸ“š Nessun chunk rilevante (soglia: 0.35)");
                return { chunks: [], maxScore: 0 };
            }
            
            console.log(`âœ… Libro: ${scoredChunks.length} chunk (score: ${maxScore.toFixed(3)})`);
            return { chunks: scoredChunks, maxScore };
            
        } catch (e) {
            console.error("âŒ Errore libro:", e);
            return { chunks: [], maxScore: 0 };
        }
    }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AI CHAT - VERSIONE ANALITICA NARRATIVA (Senza Fluff, ma Discorsiva)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function sendAIMessage() {
    const key = localStorage.getItem('gemini_key') || prompt("Inserisci la tua API Key Gemini:");
    if (!key) return; 
    localStorage.setItem('gemini_key', key);
    
    const input = document.getElementById('ai-chat-input');
    const box = document.getElementById('ai-chat-messages');
    let userText = input.value.trim();
    const originalText = userText;
    
    if (!userText) return;

    userText = espandiQueryConSinonimi(userText);
    
    box.innerHTML += `<div class="msg msg-user">${originalText}</div>`;
    input.value = "";
    input.style.height = 'auto';
    
    const aiMsgId = "ai-" + Date.now();
    box.innerHTML += `<div id="${aiMsgId}" class="msg msg-ai">â³ Analisi in corso...</div>`;
    const aiMsgElement = document.getElementById(aiMsgId);
    box.scrollTop = box.scrollHeight;

    const pContainer = document.getElementById('ai-progress-container');
    const pBar = document.getElementById('ai-progress-bar');
    pContainer.style.display = 'block';

    try {
        updateProgress(30, "Consultazione database...");
        let contextRecords = await hybridSearch(userText, 60);

        updateProgress(60, "Ricerca inerenze nel libro...");
        // Query piÃ¹ ricca per il libro: nomi + luoghi + tema
        const focusPunti = contextRecords.slice(0, 8).map(d => `${d.nominativo} ${d.regione}`).join(" ");
        const libroResult = await searchLibroSemantico(focusPunti + " " + userText, 4);
        
        let estrattiLibro = "";
        // Soglia piÃ¹ permissiva (0.35) per far entrare il libro piÃ¹ spesso
        if (libroResult.maxScore > 0.35) { 
            estrattiLibro = libroResult.chunks.map(s => s.chunk).join('\n\n');
        }

        const percorsi = analizzaPercorsiComplessi(contextRecords);
        const percorsiTesto = generaTestoPercorsi(percorsi);

        updateProgress(85, "Sintesi storiografica...");

        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:streamGenerateContent?alt=sse&key=${key}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                contents: [{
                    parts: [{
                        text: `Agisci come un Archivista Storico Analitico. Esponi i fatti senza preamboli, introduzioni o saluti. 

DATI ARCHIVIO (Usa SOLO questi per i nomi e i dati anagrafici):
${contextRecords.map(d => `[[${d.nominativo}]] | ${d.regione} | ${d.scheda}`).join('\n')}

ESTRATTI LIBRO (Contesto narrativo e approfondimento):
${estrattiLibro || "Nessun dato specifico nel libro per questa ricerca."}

RELAZIONI RILEVATE:
${percorsiTesto}

STRUTTURA OBBLIGATORIA DELLA RISPOSTA:

1. **FATTI ACCERTATI**
Presenta i partigiani trovati raggruppandoli per Brigata, zona o destino comune. Usa sempre [[Nome Cognome]] per ogni link. Sii schematico e preciso.

2. **APPROFONDIMENTI E COLLEGAMENTI**
In questa sezione Sii DISCORSIVO. Connetti le vite dei partigiani. Spiega i movimenti geografici (es: migrazioni Sud-Nord), le formazioni condivise e le date comuni. Non inventare nulla.

3. **INTEGRAZIONE DAL MEMORIALE (LIBRO)**
IMPORTANTE: Se e solo se gli "ESTRATTI LIBRO" sopra citano persone o fatti che corrispondono ai partigiani del CSV:
- Usa il tag <libro-narrato> per inserire i dettagli storici piÃ¹ ampi trovati nel libro.
- Usa il tag <libro-citazione> per riportare tra virgolette una frase significativa o una testimonianza diretta presente nel libro.
- Se il libro non aggiunge nulla di specifico, ometti questa sezione o dai un brevissimo contesto storiografico generale senza i tag.

REGOLE AGGIUNTIVE:
- Niente "Ecco i risultati" o "Certamente".
- Ogni nome partigiano deve essere tra [[ ]].
- I tag <libro-narrato> e <libro-citazione> servono per dare profonditÃ  emotiva e storica rispetto alla scheda tecnica del CSV.`
                    }]
                }]
            })
        });

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let fullText = "";
        aiMsgElement.innerHTML = ""; 

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value);
            const lines = chunk.split("\n");

            for (const line of lines) {
                if (line.startsWith("data: ")) {
                    try {
                        const json = JSON.parse(line.substring(6));
                        if (json.candidates && json.candidates[0].content.parts[0].text) {
                            fullText += json.candidates[0].content.parts[0].text;
                            aiMsgElement.innerHTML = formattaRispostaStreaming(fullText, contextRecords);
                            box.scrollTop = box.scrollHeight;
                        }
                    } catch (e) {}
                }
            }
        }

        aiMsgElement.classList.add('finished');
        updateProgress(100, "Completato");
        setTimeout(() => pContainer.style.display = 'none', 1000);

    } catch (e) {
        aiMsgElement.innerHTML = "âŒ Errore: " + e.message;
        pContainer.style.display = 'none';
    }
}

function formattaRispostaStreaming(text, records) {
    let html = text
        // Gestione grassetti e titoli
        .replace(/\*\*(.*?)\*\*/g, '<b class="ai-title">$1</b>')
        // Gestione dei tuoi link speciali [[ ]]
        .replace(/\[\[(.*?)\]\]/g, (match, nome) => {
            return `<span class="link-partigiano" onclick="apri('${nome.replace(/'/g, "\\'")}')">${nome}</span>`;
        })
        // Lasciamo passare i tag <libro-narrato> e <libro-citazione> cosÃ¬ come sono
        // perchÃ© il tuo CSS li sta giÃ  formattando!
        .replace(/\n/g, '<br>');

    return html;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FUNZIONE PRE-CALCOLO EMBEDDING (Corretta per database vuoto)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
async function precomputeAllEmbeddings() {
    if (!database || database.length === 0) {
        alert("Il database non Ã¨ ancora caricato. Attendi qualche secondo e riprova.");
        return;
    }

    const key = localStorage.getItem('gemini_key') || prompt("Inserisci API Key Gemini:");
    if (!key) return;
    localStorage.setItem('gemini_key', key);

    const btn = document.getElementById('embed-btn');
    btn.disabled = true;
    btn.innerHTML = 'â³ Sincronizzazione...';

    const monitor = document.createElement('div');
    monitor.id = 'embed-monitor';
    monitor.innerHTML = `<div style="position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); z-index:10000; background:white; border-radius:20px; padding:30px; box-shadow:0 20px 60px rgba(0,0,0,0.3); width:400px; font-family:sans-serif;">
        <h3 style="margin-top:0;">ğŸ”„ Sincronizzazione AI</h3>
        <p id="csv-stat">Elaborazione Archivio (${database.length} profili)...</p>
        <p id="libro-stat">Elaborazione Libro...</p>
        <button onclick="this.parentElement.parentElement.remove()" style="display:none; width:100%; padding:10px; border-radius:10px; border:none; background:#1a2a3a; color:white; cursor:pointer;" id="close-monitor">Chiudi</button>
    </div>`;
    document.body.appendChild(monitor);

    try {
        // 1. Calcolo CSV
        let tempCSV = [];
        for (let i = 0; i < database.length; i += 10) {
            const batch = database.slice(i, i + 10);
            const embs = await Promise.all(batch.map(async (d) => {
                const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/text-embedding-004:embedContent?key=${key}`, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model: "models/text-embedding-004", content: { parts: [{ text: `${d.nominativo} ${d.scheda} ${d.regione}` }] } })
                });
                const data = await res.json();
                return data.embedding ? data.embedding.values : null;
            }));
            tempCSV.push(...embs.filter(e => e !== null));
            document.getElementById('csv-stat').innerText = `âœ… Archivio: ${tempCSV.length} profili pronti`;
        }
        CACHE.csvEmbeddings = tempCSV;
        localStorage.setItem('csv_embeddings_v2', JSON.stringify(tempCSV));

        // 2. Calcolo Libro
        if (CACHE.libroChunks) {
            let tempLibro = [];
            const max = Math.min(CACHE.libroChunks.length, 120);
            for (let i = 0; i < max; i += 5) {
                const batch = CACHE.libroChunks.slice(i, i + 5);
                const embs = await Promise.all(batch.map(async (chunk) => {
                    const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/text-embedding-004:embedContent?key=${key}`, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ model: "models/text-embedding-004", content: { parts: [{ text: chunk.substring(0, 2000) }] } })
                    });
                    const data = await res.json();
                    return data.embedding ? data.embedding.values : null;
                }));
                tempLibro.push(...embs.filter(e => e !== null));
                document.getElementById('libro-stat').innerText = `âœ… Libro: ${tempLibro.length} sezioni pronte`;
            }
            CACHE.libroEmbeddings = tempLibro;
            localStorage.setItem('libro_embeddings_v2', JSON.stringify(tempLibro));
        }

        document.getElementById('close-monitor').style.display = 'block';
        btn.innerHTML = 'âœ… AI Sincronizzata';
    } catch (e) {
        alert("Errore calcolo: " + e.message);
        btn.disabled = false;
        btn.innerHTML = 'ğŸš€ Riprova Calcolo';
    }
// --- DENTRO sendAIMessage ---
updateProgress(30, "Consultazione database...");
let contextRecords = await hybridSearch(userText, 60);

updateProgress(60, "Ricerca inerenze nel libro...");
// Prendiamo i primi 10 nomi dal CSV per cercare nel libro
const nomiDalCSV = contextRecords.slice(0, 10).map(d => d.nominativo).join(" ");
// Interroghiamo il libro usando: Domanda Utente + Nomi trovati nel CSV + Regioni
const libroResult = await searchLibroSemantico(userText + " " + nomiDalCSV, 5);

let estrattiLibro = "";
// Usiamo una soglia che permetta al libro di entrare solo se c'Ã¨ sostanza
if (libroResult.maxScore > 0.32) { 
    estrattiLibro = libroResult.chunks.map(s => s.chunk).join('\n\n');
}

map.on('click', () => { closeDetails(); document.getElementById('results-dropdown').style.display = 'none'; });

window.addEventListener('load', () => {
    const btnHTML = `<div style="position:fixed; top:80px; right:25px; z-index:6000;">
        <button id="embed-btn" onclick="precomputeAllEmbeddings()" style="background:#2ecc71; color:white; border:none; border-radius:12px; padding:10px 15px; cursor:pointer; font-size:12px; font-weight:700; box-shadow:0 4px 10px rgba(0,0,0,0.2);">ğŸš€ Sincronizza AI (Embeddings)</button>
    </div>`;
    document.body.insertAdjacentHTML('beforeend', btnHTML);
});
</script>
</body>
</html>



